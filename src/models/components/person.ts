/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  EmploymentStatus,
  EmploymentStatus$inboundSchema,
  EmploymentStatus$outboundSchema,
} from "./employmentstatus.js";
import {
  LeaveStatus,
  LeaveStatus$inboundSchema,
  LeaveStatus$outboundSchema,
} from "./leavestatus.js";
import {
  PersonInfoSource,
  PersonInfoSource$inboundSchema,
  PersonInfoSource$Outbound,
  PersonInfoSource$outboundSchema,
} from "./personinfosource.js";
import {
  TasksSummaryStatus,
  TasksSummaryStatus$inboundSchema,
  TasksSummaryStatus$outboundSchema,
} from "./taskssummarystatus.js";
import {
  TaskSummaryDetails,
  TaskSummaryDetails$inboundSchema,
  TaskSummaryDetails$Outbound,
  TaskSummaryDetails$outboundSchema,
} from "./tasksummarydetails.js";

export type Employment = {
  /**
   * The employment status of a person:
   *
   * @remarks
   * - UPCOMING: The person is not yet employed and will start employment in the future.
   * - CURRENT: The person is currently employed.
   * - ON_LEAVE: The person is on leave.
   * - INACTIVE: The person's employment is inactive.
   * - FORMER: The person was previously employed.
   */
  status: EmploymentStatus;
  /**
   * The date the person's employment started.
   */
  startDate: Date;
  /**
   * The person's job title.
   */
  jobTitle: string | null;
  /**
   * If present, the date the person's employment ended.
   */
  endDate: Date | null;
};

/**
 * If present, the user's active/upcoming leave. Empty if the user has no active/upcoming leave.
 */
export type LeaveInfo = {
  /**
   * The start of the person's leave.
   */
  startDate: Date;
  /**
   * The end of the person's leave. Null endDate implies indefinite leave.
   */
  endDate: Date | null;
  /**
   * User can be active or upcoming leave period
   */
  status: LeaveStatus;
};

export type Name = {
  /**
   * The person's first (given) name.
   */
  first: string | null;
  /**
   * The person's last (family) name.
   */
  last: string | null;
  /**
   * The person's display name, used in Vanta.
   */
  display: string;
};

export type PersonEmployment = {
  /**
   * The source of the person's information.
   */
  endDate: PersonInfoSource;
  /**
   * The source of the person's information.
   */
  startDate: PersonInfoSource;
};

/**
 * The sources of the person's information.
 */
export type Sources = {
  employment: PersonEmployment;
  /**
   * The source of the person's information.
   */
  emailAddress: PersonInfoSource;
};

/**
 * The person's tasks summary, which aggregates their current status across
 *
 * @remarks
 * all of their relevant tasks.
 */
export type TasksSummary = {
  /**
   * All detailed information about a person's tasks, split across task categories.
   */
  details: TaskSummaryDetails;
  /**
   * The overall status of a person's outstanding tasks:
   *
   * @remarks
   * - NONE: There are no tasks.
   * - DUE_SOON: At least one task is due soon.
   * - OVERDUE: At least one task is overdue. Has a higher priority than DUE_SOON.
   * - COMPLETE: All tasks are complete.
   * - PAUSED: All tasks are paused.
   * - OFFBOARDING_DUE_SOON: At least one offboarding task is due soon.
   * - OFFBOARDING_OVERDUE: At least one offboarding task is overdue. Has a higher priority than OFFBOARDING_DUE_SOON.
   * - OFFBOARDING_COMPLETE: All offboarding tasks are complete.
   */
  status: TasksSummaryStatus;
  /**
   * The due date of the person's earliest-due task.
   */
  dueDate: Date | null;
  /**
   * The date when person's tasks were completed.
   */
  completionDate: Date | null;
};

export type Person = {
  id: string;
  emailAddress: string;
  employment: Employment;
  /**
   * If present, the user's active/upcoming leave. Empty if the user has no active/upcoming leave.
   */
  leaveInfo: LeaveInfo | null;
  /**
   * The id of each group the user belongs to. This includes both manually created groups in Vanta and groups imported from an identity provider.
   */
  groupIds: Array<string>;
  name: Name;
  /**
   * The sources of the person's information.
   */
  sources: Sources;
  /**
   * The person's tasks summary, which aggregates their current status across
   *
   * @remarks
   * all of their relevant tasks.
   */
  tasksSummary: TasksSummary;
};

/** @internal */
export const Employment$inboundSchema: z.ZodType<
  Employment,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: EmploymentStatus$inboundSchema,
  startDate: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  jobTitle: z.nullable(z.string()),
  endDate: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
});

/** @internal */
export type Employment$Outbound = {
  status: string;
  startDate: string;
  jobTitle: string | null;
  endDate: string | null;
};

/** @internal */
export const Employment$outboundSchema: z.ZodType<
  Employment$Outbound,
  z.ZodTypeDef,
  Employment
> = z.object({
  status: EmploymentStatus$outboundSchema,
  startDate: z.date().transform(v => v.toISOString()),
  jobTitle: z.nullable(z.string()),
  endDate: z.nullable(z.date().transform(v => v.toISOString())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Employment$ {
  /** @deprecated use `Employment$inboundSchema` instead. */
  export const inboundSchema = Employment$inboundSchema;
  /** @deprecated use `Employment$outboundSchema` instead. */
  export const outboundSchema = Employment$outboundSchema;
  /** @deprecated use `Employment$Outbound` instead. */
  export type Outbound = Employment$Outbound;
}

export function employmentToJSON(employment: Employment): string {
  return JSON.stringify(Employment$outboundSchema.parse(employment));
}

export function employmentFromJSON(
  jsonString: string,
): SafeParseResult<Employment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Employment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Employment' from JSON`,
  );
}

/** @internal */
export const LeaveInfo$inboundSchema: z.ZodType<
  LeaveInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  startDate: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  endDate: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  status: LeaveStatus$inboundSchema,
});

/** @internal */
export type LeaveInfo$Outbound = {
  startDate: string;
  endDate: string | null;
  status: string;
};

/** @internal */
export const LeaveInfo$outboundSchema: z.ZodType<
  LeaveInfo$Outbound,
  z.ZodTypeDef,
  LeaveInfo
> = z.object({
  startDate: z.date().transform(v => v.toISOString()),
  endDate: z.nullable(z.date().transform(v => v.toISOString())),
  status: LeaveStatus$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeaveInfo$ {
  /** @deprecated use `LeaveInfo$inboundSchema` instead. */
  export const inboundSchema = LeaveInfo$inboundSchema;
  /** @deprecated use `LeaveInfo$outboundSchema` instead. */
  export const outboundSchema = LeaveInfo$outboundSchema;
  /** @deprecated use `LeaveInfo$Outbound` instead. */
  export type Outbound = LeaveInfo$Outbound;
}

export function leaveInfoToJSON(leaveInfo: LeaveInfo): string {
  return JSON.stringify(LeaveInfo$outboundSchema.parse(leaveInfo));
}

export function leaveInfoFromJSON(
  jsonString: string,
): SafeParseResult<LeaveInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeaveInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeaveInfo' from JSON`,
  );
}

/** @internal */
export const Name$inboundSchema: z.ZodType<Name, z.ZodTypeDef, unknown> = z
  .object({
    first: z.nullable(z.string()),
    last: z.nullable(z.string()),
    display: z.string(),
  });

/** @internal */
export type Name$Outbound = {
  first: string | null;
  last: string | null;
  display: string;
};

/** @internal */
export const Name$outboundSchema: z.ZodType<Name$Outbound, z.ZodTypeDef, Name> =
  z.object({
    first: z.nullable(z.string()),
    last: z.nullable(z.string()),
    display: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Name$ {
  /** @deprecated use `Name$inboundSchema` instead. */
  export const inboundSchema = Name$inboundSchema;
  /** @deprecated use `Name$outboundSchema` instead. */
  export const outboundSchema = Name$outboundSchema;
  /** @deprecated use `Name$Outbound` instead. */
  export type Outbound = Name$Outbound;
}

export function nameToJSON(name: Name): string {
  return JSON.stringify(Name$outboundSchema.parse(name));
}

export function nameFromJSON(
  jsonString: string,
): SafeParseResult<Name, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Name$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Name' from JSON`,
  );
}

/** @internal */
export const PersonEmployment$inboundSchema: z.ZodType<
  PersonEmployment,
  z.ZodTypeDef,
  unknown
> = z.object({
  endDate: PersonInfoSource$inboundSchema,
  startDate: PersonInfoSource$inboundSchema,
});

/** @internal */
export type PersonEmployment$Outbound = {
  endDate: PersonInfoSource$Outbound;
  startDate: PersonInfoSource$Outbound;
};

/** @internal */
export const PersonEmployment$outboundSchema: z.ZodType<
  PersonEmployment$Outbound,
  z.ZodTypeDef,
  PersonEmployment
> = z.object({
  endDate: PersonInfoSource$outboundSchema,
  startDate: PersonInfoSource$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PersonEmployment$ {
  /** @deprecated use `PersonEmployment$inboundSchema` instead. */
  export const inboundSchema = PersonEmployment$inboundSchema;
  /** @deprecated use `PersonEmployment$outboundSchema` instead. */
  export const outboundSchema = PersonEmployment$outboundSchema;
  /** @deprecated use `PersonEmployment$Outbound` instead. */
  export type Outbound = PersonEmployment$Outbound;
}

export function personEmploymentToJSON(
  personEmployment: PersonEmployment,
): string {
  return JSON.stringify(
    PersonEmployment$outboundSchema.parse(personEmployment),
  );
}

export function personEmploymentFromJSON(
  jsonString: string,
): SafeParseResult<PersonEmployment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PersonEmployment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PersonEmployment' from JSON`,
  );
}

/** @internal */
export const Sources$inboundSchema: z.ZodType<Sources, z.ZodTypeDef, unknown> =
  z.object({
    employment: z.lazy(() => PersonEmployment$inboundSchema),
    emailAddress: PersonInfoSource$inboundSchema,
  });

/** @internal */
export type Sources$Outbound = {
  employment: PersonEmployment$Outbound;
  emailAddress: PersonInfoSource$Outbound;
};

/** @internal */
export const Sources$outboundSchema: z.ZodType<
  Sources$Outbound,
  z.ZodTypeDef,
  Sources
> = z.object({
  employment: z.lazy(() => PersonEmployment$outboundSchema),
  emailAddress: PersonInfoSource$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sources$ {
  /** @deprecated use `Sources$inboundSchema` instead. */
  export const inboundSchema = Sources$inboundSchema;
  /** @deprecated use `Sources$outboundSchema` instead. */
  export const outboundSchema = Sources$outboundSchema;
  /** @deprecated use `Sources$Outbound` instead. */
  export type Outbound = Sources$Outbound;
}

export function sourcesToJSON(sources: Sources): string {
  return JSON.stringify(Sources$outboundSchema.parse(sources));
}

export function sourcesFromJSON(
  jsonString: string,
): SafeParseResult<Sources, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sources$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sources' from JSON`,
  );
}

/** @internal */
export const TasksSummary$inboundSchema: z.ZodType<
  TasksSummary,
  z.ZodTypeDef,
  unknown
> = z.object({
  details: TaskSummaryDetails$inboundSchema,
  status: TasksSummaryStatus$inboundSchema,
  dueDate: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  completionDate: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
});

/** @internal */
export type TasksSummary$Outbound = {
  details: TaskSummaryDetails$Outbound;
  status: string;
  dueDate: string | null;
  completionDate: string | null;
};

/** @internal */
export const TasksSummary$outboundSchema: z.ZodType<
  TasksSummary$Outbound,
  z.ZodTypeDef,
  TasksSummary
> = z.object({
  details: TaskSummaryDetails$outboundSchema,
  status: TasksSummaryStatus$outboundSchema,
  dueDate: z.nullable(z.date().transform(v => v.toISOString())),
  completionDate: z.nullable(z.date().transform(v => v.toISOString())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TasksSummary$ {
  /** @deprecated use `TasksSummary$inboundSchema` instead. */
  export const inboundSchema = TasksSummary$inboundSchema;
  /** @deprecated use `TasksSummary$outboundSchema` instead. */
  export const outboundSchema = TasksSummary$outboundSchema;
  /** @deprecated use `TasksSummary$Outbound` instead. */
  export type Outbound = TasksSummary$Outbound;
}

export function tasksSummaryToJSON(tasksSummary: TasksSummary): string {
  return JSON.stringify(TasksSummary$outboundSchema.parse(tasksSummary));
}

export function tasksSummaryFromJSON(
  jsonString: string,
): SafeParseResult<TasksSummary, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TasksSummary$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TasksSummary' from JSON`,
  );
}

/** @internal */
export const Person$inboundSchema: z.ZodType<Person, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    emailAddress: z.string(),
    employment: z.lazy(() => Employment$inboundSchema),
    leaveInfo: z.nullable(z.lazy(() => LeaveInfo$inboundSchema)),
    groupIds: z.array(z.string()),
    name: z.lazy(() => Name$inboundSchema),
    sources: z.lazy(() => Sources$inboundSchema),
    tasksSummary: z.lazy(() => TasksSummary$inboundSchema),
  });

/** @internal */
export type Person$Outbound = {
  id: string;
  emailAddress: string;
  employment: Employment$Outbound;
  leaveInfo: LeaveInfo$Outbound | null;
  groupIds: Array<string>;
  name: Name$Outbound;
  sources: Sources$Outbound;
  tasksSummary: TasksSummary$Outbound;
};

/** @internal */
export const Person$outboundSchema: z.ZodType<
  Person$Outbound,
  z.ZodTypeDef,
  Person
> = z.object({
  id: z.string(),
  emailAddress: z.string(),
  employment: z.lazy(() => Employment$outboundSchema),
  leaveInfo: z.nullable(z.lazy(() => LeaveInfo$outboundSchema)),
  groupIds: z.array(z.string()),
  name: z.lazy(() => Name$outboundSchema),
  sources: z.lazy(() => Sources$outboundSchema),
  tasksSummary: z.lazy(() => TasksSummary$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Person$ {
  /** @deprecated use `Person$inboundSchema` instead. */
  export const inboundSchema = Person$inboundSchema;
  /** @deprecated use `Person$outboundSchema` instead. */
  export const outboundSchema = Person$outboundSchema;
  /** @deprecated use `Person$Outbound` instead. */
  export type Outbound = Person$Outbound;
}

export function personToJSON(person: Person): string {
  return JSON.stringify(Person$outboundSchema.parse(person));
}

export function personFromJSON(
  jsonString: string,
): SafeParseResult<Person, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Person$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Person' from JSON`,
  );
}
